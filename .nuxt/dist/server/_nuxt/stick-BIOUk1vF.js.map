{"version":3,"file":"stick-BIOUk1vF.js","sources":["../../../../app/pages/stick.vue"],"sourcesContent":["<template>\r\n  <section class=\"stick-page\">\r\n    <header class=\"stick-page__header\">\r\n      <h1 class=\"stick-page__title\">Cane Simulation (Audio Hunt)</h1>\r\n      <p class=\"stick-page__lead\">\r\n        Find hidden targets using sound only. Your cane sends a “ping” and you\r\n        must follow the audio cue (volume + stereo pan) to locate the target.\r\n      </p>\r\n      <p class=\"stick-page__instructions\">\r\n        Use <strong>arrow keys</strong> to move. Press <strong>Space</strong>\r\n        to ping. When you think you’re on the target tile, press\r\n        <strong>Enter</strong> to “pick up” the target.\r\n      </p>\r\n    </header>\r\n\r\n    <main class=\"stick-page__main\">\r\n      <section\r\n        class=\"stick-page__arena\"\r\n        tabindex=\"0\"\r\n        role=\"application\"\r\n        aria-label=\"Audio hunt cane game. Arrow keys to move. Space to ping. Enter to pick up the target.\"\r\n        @keydown.prevent=\"onKeydown\"\r\n      >\r\n        <div class=\"hud\" aria-live=\"polite\">\r\n          <div class=\"hud__row\">\r\n            <span>Targets found: <strong>{{ found }}</strong> / {{ goalCount }}</span>\r\n            <span>Moves: <strong>{{ moves }}</strong></span>\r\n          </div>\r\n          <div class=\"hud__row\">\r\n            <span>Last ping distance: <strong>{{ lastDistanceLabel }}</strong></span>\r\n            <span v-if=\"isOnTarget\" class=\"hud__hot\">Target is here</span>\r\n          </div>\r\n        </div>\r\n\r\n        <p class=\"stick-page__status\" aria-live=\"polite\">{{ message }}</p>\r\n\r\n        <!-- Minimal visual: show only your position as a tiny dot (still mostly dark) -->\r\n        <div class=\"mini\" aria-hidden=\"true\">\r\n          <div\r\n            class=\"mini__dot\"\r\n            :style=\"{ left: `${(playerX / (gridSize - 1)) * 100}%`, top: `${(playerY / (gridSize - 1)) * 100}%` }\"\r\n          />\r\n        </div>\r\n      </section>\r\n\r\n      <section class=\"stick-page__notes\">\r\n        <h2>What this tries to show</h2>\r\n        <p>\r\n          In real life, people learn to map space through sound, touch and\r\n          repetition. This mini-game exaggerates that: you must build a mental\r\n          map and use audio cues to navigate.\r\n        </p>\r\n      </section>\r\n    </main>\r\n  </section>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { computed, onMounted, ref } from 'vue'\r\n\r\n// Audio-only “target hunt”\r\nconst gridSize = 11\r\nconst goalCount = 3\r\n\r\nconst playerX = ref(5)\r\nconst playerY = ref(9)\r\n\r\ntype Target = { x: number; y: number; found: boolean }\r\nconst targets = ref<Target[]>([])\r\n\r\nconst found = computed(() => targets.value.filter((t) => t.found).length)\r\nconst moves = ref(0)\r\nconst message = ref('Press Space to ping. Use the sound to find targets.')\r\nconst lastDistance = ref<number | null>(null)\r\n\r\n// --- Audio engine (beeps with stereo pan + volume based on distance) ---\r\nconst audioCtx = ref<AudioContext | null>(null)\r\nconst master = ref<GainNode | null>(null)\r\nconst panner = ref<StereoPannerNode | null>(null)\r\nconst beep = (distance: number, panValue: number) => {\r\n  try {\r\n    const ctx = audioCtx.value\r\n    const m = master.value\r\n    const p = panner.value\r\n    if (!ctx || !m || !p) return\r\n\r\n    const osc = ctx.createOscillator()\r\n    osc.type = 'sine'\r\n    // closer = higher pitch\r\n    osc.frequency.value = 250 + Math.max(0, 220 - distance * 12)\r\n\r\n    const gain = ctx.createGain()\r\n    const volume = Math.max(0.02, Math.min(0.35, 0.35 - distance * 0.03))\r\n    gain.gain.value = 0\r\n\r\n    // Set pan instantly for the ping\r\n    p.pan.setValueAtTime(panValue, ctx.currentTime)\r\n\r\n    osc.connect(gain).connect(p)\r\n    gain.gain.setValueAtTime(0.0001, ctx.currentTime)\r\n    gain.gain.exponentialRampToValueAtTime(volume, ctx.currentTime + 0.02)\r\n    gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.26)\r\n\r\n    osc.start()\r\n    osc.stop(ctx.currentTime + 0.28)\r\n  } catch {\r\n    // ignore\r\n  }\r\n}\r\n\r\nconst ensureAudio = async () => {\r\n  if (audioCtx.value) return\r\n  audioCtx.value = new AudioContext()\r\n  const ctx = audioCtx.value\r\n  const m = ctx.createGain()\r\n  m.gain.value = 0.35\r\n  const p = new StereoPannerNode(ctx, { pan: 0 })\r\n  p.connect(m).connect(ctx.destination)\r\n  master.value = m\r\n  panner.value = p\r\n}\r\n\r\nconst randomInt = (min: number, max: number) => Math.floor(Math.random() * (max - min + 1)) + min\r\n\r\nconst spawnTargets = () => {\r\n  const next: Target[] = []\r\n  while (next.length < goalCount) {\r\n    const x = randomInt(0, gridSize - 1)\r\n    const y = randomInt(0, gridSize - 1)\r\n    // avoid starting near player\r\n    const d = Math.abs(x - playerX.value) + Math.abs(y - playerY.value)\r\n    if (d < 4) continue\r\n    if (next.some((t) => t.x === x && t.y === y)) continue\r\n    next.push({ x, y, found: false })\r\n  }\r\n  targets.value = next\r\n}\r\n\r\nconst nearestTarget = computed(() => {\r\n  const remaining = targets.value.filter((t) => !t.found)\r\n  if (remaining.length === 0) return null\r\n  let best = remaining[0]\r\n  let bestDist = Infinity\r\n  for (const t of remaining) {\r\n    const d = Math.abs(t.x - playerX.value) + Math.abs(t.y - playerY.value)\r\n    if (d < bestDist) {\r\n      bestDist = d\r\n      best = t\r\n    }\r\n  }\r\n  return { target: best, dist: bestDist }\r\n})\r\n\r\nconst isOnTarget = computed(() => {\r\n  return targets.value.some((t) => !t.found && t.x === playerX.value && t.y === playerY.value)\r\n})\r\n\r\nconst lastDistanceLabel = computed(() => {\r\n  if (lastDistance.value === null) return '—'\r\n  if (lastDistance.value === 0) return 'here'\r\n  if (lastDistance.value <= 2) return 'very close'\r\n  if (lastDistance.value <= 5) return 'close'\r\n  if (lastDistance.value <= 9) return 'far'\r\n  return 'very far'\r\n})\r\n\r\nconst move = (dx: number, dy: number) => {\r\n  const nx = playerX.value + dx\r\n  const ny = playerY.value + dy\r\n  if (nx < 0 || ny < 0 || nx >= gridSize || ny >= gridSize) {\r\n    message.value = 'Wall. You cannot go further.'\r\n    return\r\n  }\r\n  playerX.value = nx\r\n  playerY.value = ny\r\n  moves.value++\r\n  message.value = 'Step.'\r\n}\r\n\r\nconst ping = async () => {\r\n  await ensureAudio()\r\n  const best = nearestTarget.value\r\n  if (!best) {\r\n    message.value = 'No targets left.'\r\n    return\r\n  }\r\n\r\n  lastDistance.value = best.dist\r\n  // pan based on relative x (-1..1)\r\n  const dx = best.target.x - playerX.value\r\n  const panValue = Math.max(-1, Math.min(1, dx / 4))\r\n  message.value = 'Ping… follow the sound.'\r\n  beep(best.dist, panValue)\r\n}\r\n\r\nconst pickup = () => {\r\n  const t = targets.value.find((tt) => !tt.found && tt.x === playerX.value && tt.y === playerY.value)\r\n  if (!t) {\r\n    message.value = 'Nothing here.'\r\n    return\r\n  }\r\n\r\n  t.found = true\r\n  message.value = 'Found it.'\r\n  lastDistance.value = 0\r\n  // Achievement\r\n  if (typeof window !== 'undefined') {\r\n    window.dispatchEvent(\r\n      new CustomEvent('blindsite:achievement', {\r\n        detail: { key: 'finder', text: 'Seeker: you found a target by sound.' },\r\n      })\r\n    )\r\n  }\r\n\r\n  if (found.value >= goalCount) {\r\n    message.value = `All targets found in ${moves.value} moves. Great job.`\r\n    if (typeof window !== 'undefined') {\r\n      window.dispatchEvent(\r\n        new CustomEvent('blindsite:achievement', {\r\n          detail: { key: 'caneMaster', text: 'Cane master: you completed the audio hunt.' },\r\n        })\r\n      )\r\n    }\r\n  }\r\n}\r\n\r\nconst onKeydown = (event: KeyboardEvent) => {\r\n  switch (event.key) {\r\n    case 'ArrowUp':\r\n      move(0, -1)\r\n      break\r\n    case 'ArrowDown':\r\n      move(0, 1)\r\n      break\r\n    case 'ArrowLeft':\r\n      move(-1, 0)\r\n      break\r\n    case 'ArrowRight':\r\n      move(1, 0)\r\n      break\r\n    case ' ':\r\n    case 'Spacebar':\r\n      ping()\r\n      break\r\n    case 'Enter':\r\n      pickup()\r\n      break\r\n  }\r\n}\r\n\r\nonMounted(() => {\r\n  spawnTargets()\r\n  // Achievement: entered the cane page\r\n  if (typeof window !== 'undefined') {\r\n    window.dispatchEvent(\r\n      new CustomEvent('blindsite:achievement', {\r\n        detail: { key: 'cane', text: 'Navigator: you started the cane audio hunt.' },\r\n      })\r\n    )\r\n  }\r\n})\r\n</script>\r\n\r\n<style scoped>\r\n.stick-page {\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 2.5rem;\r\n}\r\n\r\n.stick-page__header {\r\n  display: grid;\r\n  gap: 1rem;\r\n}\r\n\r\n.stick-page__title {\r\n  font-size: clamp(2rem, 3vw, 2.6rem);\r\n}\r\n\r\n.stick-page__lead,\r\n.stick-page__instructions {\r\n  max-width: 42rem;\r\n  color: #e5e7eb;\r\n}\r\n\r\n.stick-page__main {\r\n  display: grid;\r\n  gap: 2.5rem;\r\n}\r\n\r\n.stick-page__arena {\r\n  border-radius: 1rem;\r\n  border: 1px solid rgba(148, 163, 184, 0.5);\r\n  padding: 1.25rem;\r\n  background: radial-gradient(circle at top, #020617 0, #020617 40%, #000 100%);\r\n  outline: none;\r\n}\r\n\r\n.stick-page__arena:focus-visible {\r\n  box-shadow: 0 0 0 2px #f97316;\r\n}\r\n\r\n.hud {\r\n  display: grid;\r\n  gap: 0.4rem;\r\n  margin-bottom: 0.9rem;\r\n  color: rgba(229, 231, 235, 0.95);\r\n  font-size: 0.95rem;\r\n}\r\n\r\n.hud__row {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  gap: 1rem;\r\n}\r\n\r\n.hud__hot {\r\n  color: #fbbf24;\r\n  font-weight: 700;\r\n}\r\n\r\n.stick-page__status {\r\n  color: rgba(229, 231, 235, 0.92);\r\n  margin: 0 0 1.1rem;\r\n}\r\n\r\n.mini {\r\n  position: relative;\r\n  height: 260px;\r\n  border-radius: 0.9rem;\r\n  border: 1px solid rgba(148, 163, 184, 0.28);\r\n  background: rgba(0, 0, 0, 0.4);\r\n  overflow: hidden;\r\n}\r\n\r\n.mini__dot {\r\n  position: absolute;\r\n  width: 10px;\r\n  height: 10px;\r\n  border-radius: 999px;\r\n  transform: translate(-50%, -50%);\r\n  background: rgba(251, 191, 36, 0.9);\r\n  box-shadow: 0 0 20px rgba(251, 191, 36, 0.35);\r\n}\r\n\r\n.stick-page__notes {\r\n  max-width: 42rem;\r\n  color: #e5e7eb;\r\n}\r\n\r\n.stick-page__notes h2 {\r\n  font-size: 1.3rem;\r\n  margin-bottom: 0.5rem;\r\n}\r\n</style>\r\n"],"names":["_ssrRenderAttrs","_mergeProps","_ssrRenderStyle"],"mappings":";;;;;;;;;;;;;;;AA6DA,MAAM,WAAW;AACjB,MAAM,YAAY;;;;;AAElB,UAAM,UAAU,IAAI,CAAC;AACrB,UAAM,UAAU,IAAI,CAAC;AAGrB,UAAM,UAAU,IAAc,EAAE;AAEhC,UAAM,QAAQ,SAAS,MAAM,QAAQ,MAAM,OAAO,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM;AACxE,UAAM,QAAQ,IAAI,CAAC;AACnB,UAAM,UAAU,IAAI,qDAAqD;AACzE,UAAM,eAAe,IAAmB,IAAI;AAG3B,QAAyB,IAAI;AAC/B,QAAqB,IAAI;AACzB,QAA6B,IAAI;AA4D1B,aAAS,MAAM;AACnC,YAAM,YAAY,QAAQ,MAAM,OAAO,CAAC,MAAM,CAAC,EAAE,KAAK;AACtD,UAAI,UAAU,WAAW,EAAG,QAAO;AACnC,UAAI,OAAO,UAAU,CAAC;AACtB,UAAI,WAAW;AACf,iBAAW,KAAK,WAAW;AACzB,cAAM,IAAI,KAAK,IAAI,EAAE,IAAI,QAAQ,KAAK,IAAI,KAAK,IAAI,EAAE,IAAI,QAAQ,KAAK;AACtE,YAAI,IAAI,UAAU;AAChB,qBAAW;AACX,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO,EAAE,QAAQ,MAAM,MAAM,SAAA;AAAA,IAC/B,CAAC;AAED,UAAM,aAAa,SAAS,MAAM;AAChC,aAAO,QAAQ,MAAM,KAAK,CAAC,MAAM,CAAC,EAAE,SAAS,EAAE,MAAM,QAAQ,SAAS,EAAE,MAAM,QAAQ,KAAK;AAAA,IAC7F,CAAC;AAED,UAAM,oBAAoB,SAAS,MAAM;AACvC,UAAI,aAAa,UAAU,KAAM,QAAO;AACxC,UAAI,aAAa,UAAU,EAAG,QAAO;AACrC,UAAI,aAAa,SAAS,EAAG,QAAO;AACpC,UAAI,aAAa,SAAS,EAAG,QAAO;AACpC,UAAI,aAAa,SAAS,EAAG,QAAO;AACpC,aAAO;AAAA,IACT,CAAC;;uBAnKUA,eAAAC,WAAA,EAAA,OAAM,aAAA,GAAY,MAAA,CAAA,igCAwBe,MAAA,KAAK,+BAAkB,SAAS,+EACxC,MAAA,KAAK,iJAGQ,kBAAA,KAAiB;UAC1C,WAAA,OAAU;;;;;2GAI0B,QAAA,KAAO,2FAMnCC,eAAA,EAAA,MAAA,GAAA,QAAA,SAAW,WAAQ,KAAA,GAAA,KAAA,KAAA,GAA0B,QAAA,SAAW,WAAQ,KAAA,GAAA,IAAA,CAAA;;;;;;;;;;;"}